Resumo
Introdu√ß√£o ao RBAC
RBAC √© um termo comum no mundo de infraestrutura, que serve para dar permiss√£o de acesso √† recursos privados baseado em roles (fun√ß√µes). Por exemplo, DevOps tem acesso a X, enquanto Desenvolvedores tem acesso a Y.

Isso vem muito de encontro com o princ√≠pio de least-privilege. Dar somente as permiss√µes necess√°rias para quem realmente precisa, diminuindo os vetores de ataques.

No Kubernetes, temos um sistema de RBAC para controlar as chamadas do API server. Isso √© especialmente √∫til em dois cen√°rios:

Dar permiss√µes para usu√°rios finais que precisam de acesso ao nosso cluster Kubernetes (read-write? read-only?).

Dar permiss√µes para Service Accounts sendo usadas por outros pods dentro do cluster.

CSR de usu√°rio no Kubernetes
O primeiro passo √© criar uma CSR (Certificate Signing Request) localmente. Essa CSR ser√° enviada para a CA do Kubernetes assinar e devolver o real certificado.

openssl req -nodes \
	  -days 365 \
	  -newkey rsa:2048 \
	  -keyout estagiario.key \
	  -out estagiario.csr \
	  -subj '/CN=estagiario/O=mateusmullerme' \
	  -addext 'subjectAltName = DNS:estagiario.mateusmuller.me'
A assinatura do certificado ser√° realizada dentro do pr√≥prio cluster via YAML. Para isso vamos encodar a CSR.

cat estagiario.csr| base64 -w 0
E usar o seguinte padr√£o:

apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: estagiario-csr
spec:
  request: <csr aqui>
  signerName: kubernetes.io/kube-apiserver-client
  usages:
  - client auth
Note que estamos pedindo um certificado do tipo client para autentica√ß√£o com o cluster. Vou deixar algumas refer√™ncias oficiais sobre isso aqui:

Authenticating

Certificates and Certificate Signing Requests

Manage TLS Certificates in a Cluster

Agora vamos aprovar a CSR, pegar o certificado e analisar o conte√∫do.

kubectl certificate approve estagiario-csr
kubectl get csr estagiario-csr -ojson |\
		jq -r .status.certificate |\
		base64 -d > estagiario.crt
openssl x509 -in estagiario.crt -text
Note que foi assinado pela CA ‚ÄúCN = kubernetes‚Äù. Este certificado est√° pronto para ser usado no processo de autentica√ß√£o.

Configurando usu√°rio no kubectl context
Para configurarmos a autentica√ß√£o do kubectl, precisamos editar o famoso kubeconfig. Ao inv√©s de fazer isso ‚Äúna munheca‚Äù, vamos usar o pr√≥prio kubectl que n√£o tem erro.

$ kubectl config set-credentials estagiario \
		--client-certificate estagiario.crt \
		--client-key estagiario.key
	
$ kubectl config set-context estagiario \
		--cluster kind-kind \
		--user estagiario
 
$ kubectl config use-context estagiario
 
$ kubectl get pods
Provavelmente voc√™ vai receber um erro parecido com este aqui:

Error from server (Forbidden): pods is forbidden: User "estagiario" cannot list resource "pods" in API group "" in the namespace "default"
Note que a autentica√ß√£o j√° est√° funcionando. O Kubernetes identificou o nome do usu√°rio baseado no CN do certificado e at√© mostrou na mensagem de erro!

A jogada agora √© fazer o RBAC deste mesmo usu√°rio.

ClusterRole e ClusterRoleBinding
Aqui voc√™ pode ver as RBACs que j√° vem em todos os clusters, default do Kubernetes mesmo.

Using RBAC Authorization

Existe uma ClusterRole muito interessante para os nossos estagi√°rios: view. Pode ver as informa√ß√µes do cluster, mas n√£o pode modificar (para evitar maiores problemas rsrs).

Bastaria a gente criar um binding mais ou menos assim:

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: estagiario-ro
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- kind: User
  name: estagiario
  apiGroup: rbac.authorization.k8s.io
E problema resolvido! üôÇ

Role, RoleBinding e ServiceAccounts
Se voc√™ precisar liberar acesso aos recursos de namespace, use Role. Se o recurso for cluster-wide, use ClusterRole. Basicamente essa √© a regra.

Podemos iniciar um pod com kubectl para testar isso.

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: kubectl
  name: kubectl
spec:
  serviceAccountName: kubectl
  containers:
  - image: bitnami/kubectl
    name: kubectl
    command:
      - sleep
      - "999999999999999"
Kubernetes API Concepts

Quando voc√™ executar alguma a√ß√£o com kubectl, uma mensagem de erro ser√° mostrada no terminal informando exatamente qual chamada voc√™ est√° fazendo e para qual objeto. Com isso, basta adicionar na Role para dar acesso.

Isso √© interessante porque voc√™ apenas d√° acesso aos recursos que a aplica√ß√£o precisa e nada mais. O famoso princ√≠pio de least privilege.

Voc√™ sempre cria a Role e RoleBinding na namespace onde o recurso que voc√™ quer dar acesso est√° localizado. J√° a ServiceAccount pode estar localizada em outra namespace.

A l√≥gica das chamadas segue a mesma entre Role e ClusterRole.

A diferen√ßa √© que a Role se aplica para recursos namespaced. Voc√™ pode filtrar todos com o seguinte comando:

$ kubectl api-resources --namespaced